<html>

<head>
    <link rel="stylesheet" href="pico.css" />
    <style>
        #timeline-container {
            width: 100%;
            position: relative;
            height: 50px;
            background-color: transparent;
            border: 1px solid #ccc;
            overflow-x: scroll;
            overflow-y: hidden;
            margin-top: 20px;
        }

        #timeline {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: flex-start;
            width: 100%;
            white-space: nowrap;
        }

        .tick {
            position: absolute;
            width: 1px;
            bottom: 0;
            height: 30%;
            background-color: gray;
        }
        .tickHeigh {
            position: absolute;
            width: 1px;
            bottom: 0;
            height: 60%;
            background-color: white;
        }

        .tick-label {
            position: absolute;
            font-size: 10px;
            top: 0px;
            text-align: left;

            height: 100px;
            z-index: 1;

        }

        .tick-label-selected {
            border: 2px solid var(--pico-primary);
        }

        .tick-label:hover {
            border: 2px solid var(--pico-secondary);
        }
    </style>
</head>

<body st>
    <header class="container">
        <hgroup>
            <h1> PICam </h1>
        </hgroup>
        <div class="grid">
            <button id="goToLivePageButton" onclick="goToLivePage()">Live</button>
            <button id="goToArchivePageButton" class="secondary" onclick="goToArchivePage()">Archive</button>
        </div>
    </header>
    <main class="container">
        <div style="visibility: hidden;" class="container" id="archive">
            <div id="timeline-container">
                <div id="timeline"></div>
            </div>
        </div>
        <video style="width: 100%;" id="player" autoplay></video>
        <progress id="progress"></progress>
    </main>
</body>
<script>
function createTimeline(archiveList) {
    const timeline = document.getElementById('timeline');
    timeline.innerHTML = "";

    archiveList.sort();

    const archiveDateTimeList = [];

    for(let i=0; i<archiveList.length; i++) {
        archiveDateTimeList.push(new Date(archiveList[i].slice(0, -4)));
    }


    const tickSpacing = 10;   // Space between ticks (in pixels)
    
    // Generate ticks and labels
    let minuteOffSet = 0;
    for (let i = 0; i < (archiveDateTimeList.length -1); i++) {
        let minutes = Math.abs(archiveDateTimeList[i+1] -archiveDateTimeList[i]) / (1000 * 60);
        // Add a label for every archive
        const label = document.createElement('div');
        label.classList.add('tick-label');
        label.textContent = archiveDateTimeList[i].getHours() 
            + ":" 
            + archiveDateTimeList[i].getMinutes() 
            + ":" 
            + archiveDateTimeList[i].getSeconds();
        label.style.left = `${minuteOffSet * tickSpacing}px`;
        label.style.width = `${(minutes + 1) * tickSpacing }px`;

        label.addEventListener("click", (event) => {
            playRecording(archiveList[i]);
            const labels = document.getElementsByClassName('tick-label');
            Array.from(labels).forEach(l => {
                l.classList.remove('tick-label-selected')
            });

            label.classList.add('tick-label-selected');
        })

        timeline.appendChild(label);
        for(let j= 0 ; j<minutes; j++) {
            const tick = document.createElement('div');
            if(j===0) {
                tick.classList.add('tickHeigh');
            } else {
                tick.classList.add('tick');
            }
            tick.style.left = `${minuteOffSet * tickSpacing}px`; // Set the position of each tick
            timeline.appendChild(tick);
            minuteOffSet += 1;
        }
        
    }
};

    let video = document.getElementById('player');
    let mediaSource = null;
    let sourceBuffer = null;
    let socket = null;
    let collectedData = [];
    let opened = false;

    function goToLivePage() {
        document.getElementById("goToLivePageButton").className = "";
        document.getElementById("goToArchivePageButton").className = "secondary";
        document.getElementById("progress").style.visibility = "visible";
        document.getElementById("archive").style.visibility = "hidden";
        removeVideoSrc();
        createVideoSource();
    }

    function goToArchivePage() {
        document.getElementById("goToLivePageButton").className = "secondary";
        document.getElementById("goToArchivePageButton").className = "";

        if (socket != null) {
            socket.close(1000);
        }
        removeVideoSrc();
        document.getElementById("progress").style.visibility = "hidden";
        document.getElementById("archive").style.visibility = "visible";
        refreshArchive();
    }

    function playRecording(recording) {
        removeVideoSrc();
        video.src = "http://localhost:3000/api/recordings/"+recording;
        video.load();
    }

    function refreshArchive() {
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                let archive = JSON.parse(xhttp.responseText);
                createTimeline(archive);
            }
        };
        xhttp.open("GET", "http://localhost:3000/api/recordings", true);
        xhttp.send();
    }
    
    function removeVideoSrc() {
        video.removeAttribute('src');
        video.load();
        if (mediaSource != null) {
            delete mediaSource;
            mediaSource = null;
        }
    }

    video.ontimeupdate = () => {
        if (sourceBuffer) {
            document.getElementById("progress").style.visibility = "hidden";

            let length = sourceBuffer.buffered.length;
            let seconds = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
            if (seconds - video.currentTime > 5) {
                video.playbackRate = 1.5;
            } else if (seconds - video.currentTime < 0.75) {
                video.playbackRate = 0.25;
            } else {
                video.playbackRate = 1.0;
            }
        }
    }

    function createVideoSource() {
        opened = false;
        mediaSource = new MediaSource();
        mediaSource.addEventListener("sourceopen", this.onSourceOpen);
        
        video.src = URL.createObjectURL(mediaSource);
        video.load();
    }


    function onSourceOpen() {

        if (opened) {
            return;
        }
        opened = true;

        let codec = 'video/mp4; codecs="avc1.42E01e"';
        if (!MediaSource.isTypeSupported(codec)) {
            console.error("Codec not supported");
            return;
        }
        sourceBuffer = mediaSource.addSourceBuffer(codec);
        sourceBuffer.mode = "sequence";
        sourceBuffer.addEventListener("updateend", () => {

        });

        function addToBuffer(data) {
            collectedData.push(data);
            if (sourceBuffer) {
                while(!sourceBuffer.updating) {
                    let seg = collectedData.shift();
                    if (seg) {
                        sourceBuffer.appendBuffer(seg);
                    }
                }
            }
        }


        // Open websocket
        socket = new WebSocket("ws://localhost:3000/ws");

        socket.addEventListener("message", async (event) => {
            let data = await event.data.arrayBuffer();
            addToBuffer(data);
        });

    }

    createVideoSource();




</script>

</html>